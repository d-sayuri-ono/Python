# -*- coding: utf-8 -*-
"""Untitled11.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1YOm2EV6SP5ZPjxv7x60xU514ZGJCXsBN

### Importação de bibliotecas e módulos
"""

"""

 --- Aluna: Daniele Sayuri Ono
 --- Curso de Tecnologia em Inteligência Artificial Aplicada
 --- Disciplina: Raciocínio Computacional

"""

#-------------------------------------------------------------------------------
# -- BIBLIOTECAS --

# Importar Bibliotecas
# -- Gerar números aleatórios
from random import randint, randrange, choice

# -- Finalizar execução do código
import sys

# -- Criar pausas
from time import sleep

"""### Funções"""

#-------------------------------------------------------------------------------

# -- MANIPULAÇÃO DOS DADOS --

# Criar os Dados
# -- 6 dados verdes : CPCTPC 
# -- 4 dados amarelos : TPCTPC 
# -- 3 dados vermelhos : TPTCPT 
# C : cérebro | P : passos | T : tiro

# -- MANIPULAÇÃO DOS DADOS --

# Criar os Dados
# -- 6 dados verdes : CPCTPC 
# -- 4 dados amarelos : TPCTPC 
# -- 3 dados vermelhos : TPTCPT 
# C : cérebro | P : passos | T : tiro

#Função para criar os tipos de dados
def select_dado_verde():
  dado_verde = ('C', 'P', 'C', 'T', 'P', 'C')
  return dado_verde

def select_dado_amarelo():
  dado_amarelo = ('T', 'P', 'C', 'T', 'P', 'C')
  return dado_amarelo

def select_dado_vermelho():
  dado_vermelho = ('T', 'P', 'T', 'C', 'P', 'T')
  return dado_vermelho

# Função para inicializar e armazenar os dados dentro do copo
def armazenar_dados_copo(copo): 
  # Armazenar dados verdes
  for i in range(0,6):
    copo.append(select_dado_verde())
  # Armazenar dados amarelos
  for i in range(0,4):
    copo.append(select_dado_amarelo())
  # Armazenar dados vermelhos
  for i in range(0,3):
    copo.append(select_dado_vermelho())
  return copo

# Função para pegar os dados do copo
def pegar_dados_copo(copo):
    # Wellington: teremos problemas no código do randrange se tivermos só 1 dado. Colocando uma lógica extra
    if len(copo) == 1:
      dado = copo.pop(0)
      return (dado, copo)
    elif len(copo) != 0:
      n_dados = (len(copo) - 1)
      dado_sorteado = randrange(0, n_dados)
      dado = copo[dado_sorteado]
      #copo.remove(dado)
      # Wellington: removendo um dado de uma posição em específico com o pop
      copo.pop(dado_sorteado)
      return (dado, copo)
    else:
      print('O copo está vazio!')
      return (-1, copo)

# Função para lançar os dados
def lancar_dados(dado):
  # Wellington: esta função está bem estranha. Parece que no lugar do for era para ser um randint ou um choice.
  #for face_dado in range(0,5):
  face_dado = dado[choice(range(0, 5))]
  if face_dado == 'C':
    print('CÉÉÉÉREBRO!!! PARABÉNS, VOCÊ COMEU UM CÉREBRO!\n')
    return 'C'
  elif face_dado == 'T':
    print('+++++ TIRO +++++ QUE AZAR, VOCÊ LEVOU UM TIRO!\n')
    return 'T'
  else:
    print('.....PASSOS..... PARECE QUE UMA VÍTIMA FUGIU!\n')
    return 'P'

# Função para mostrar os dados que estão dentro do copo
def mostrar_dados_copo(copo):
  lista_dados = []
  for dado in range(0, len(copo)):
    if copo[dado] == ('C', 'P', 'C', 'T', 'P', 'C'):
      lista_dados.append('VERDE')
    elif copo[dado] == ('T', 'P', 'C', 'T', 'P', 'C'):
      lista_dados.append('AMARELO')
    else:
      lista_dados.append('VERMELHO')
  print(lista_dados)

# Função para mostrar a cor dos dados
def mostrar_cor_dados(dado):
  if dado == ('C', 'P', 'C', 'T', 'P', 'C'):
    print('DADO VERDE')
  elif dado == ('T', 'P', 'C', 'T', 'P', 'C'):
    print('DADO AMARELO')
  else:
    print('DADO VERMELHO')


#-------------------------------------------------------------------------------

# -- VERIFICAR O SCORE DO JOGO --

# Função para verificar score do jogo
def consultar_score(primeiro, segundo, terceiro):
  # Inicializando as variáveis
  tiros = 0
  cerebros = 0
  passos = 0
  # Tabela de scores
  # -- Primeiro --
  if primeiro == 'C':
    cerebros += 1
  elif primeiro == 'T':
    tiros += 1
  else:
    passos += 1
  # -- Segundo --
  if segundo == 'C':
    cerebros += 1
  elif segundo == 'T':
    tiros += 1
  else:
    passos += 1 
  # -- Terceiro --
  if terceiro == 'C':
    cerebros += 1
  elif terceiro == 'T':
    tiros += 1
  else:
    passos += 1
  # Retornar lista
  return (cerebros, tiros, passos)

# Difinir qual jogador iniciará a partida
def escolher_primeiro_jogador(jogador):
  '''
  print("Vamos determinar o jogador que iniciará a partida!\n")

  jogador_com_maior_contador = 0
  maior_contador = 0

  for i in range (n_jogadores):
    print("Jogador {}" .format(i+1))
    texto = input('Insira a palavra "CÉREBRO" da maneira mais zumbi possível: ')
    letra_anterior = ""
    contador_letras = 0

    for letra_atual in texto:
      if letra_atual == letra_anterior:
        contador_letras += 1

      letra_anterior = letra_atual
    print("Total de letras repetidas: ",contador_letras)

    if contador_letras > maior_contador:
        maior_contador = contador_letras
        jogador_maior_contador = (i+1)
  
  return jogador_maior_contador
  '''
  # Wellington: comentei a lógica anterior para acelerar os testes. Por padrão, o primeiro jogador é escolhido aleatoriamente.
  return choice(range(n_jogadores))

#-------------------------------------------------------------------------------

# -- MENU DE INICIALIZAÇÃO DO JOGO --

# Criar o Menu de Inicialização do jogo
print('='*85)
print('                             Z O M B I E   D I C E                                  ')
print('\n')
print('        Bem-vindo ao Zombie Dice! Preparado para a melhor experiência zombie?       ')
print('='*85)
print('\n')
#input('                        Pressione ENTER para continuar! ') # Wellington: removi isto para que possamos testar o código sem apertar Enter toda hora
print('-'*85)

#-------------------------------------------------------------------------------

# -- ENTRADA DOS JOGADORES --

# Criar a entrada do número de jogadores
'''
n_jogadores = int(input('Insira o número de jogadores: '))

# Validar se o número de jogadores é maior que 2 jogadores
while n_jogadores < 2:
  print('Para iniciar o jogo, é necessário ter no mímino 2 jogadores!\n')
  # Validar se o jogador deseja continuar jogando
  continuar_jogo = input('Deseja continuar? [S - SIM | N - NÃO]: \n').upper()
  if continuar_jogo == 'S':
    n_jogadores = int(input('Insira o número de jogadores: '))
  elif continuar_jogo == 'N':
    print('Jogo encerrado! Até a próxima!')
    sys.exit()
  else:
    print('Tecla selecionada é inválida. Selecione S para SIM ou N para NÃO')

# Armazenar jogadores em uma lista e inicializar as variáveis
lista_jogadores = []
lista_nome_jogadores = []
for i in range(n_jogadores):
  nome_jogador = input('Insira o nome do {}° jogador: '.format(i+1)).upper()
  # Armazenar o nome dos jogadores em uma lista
  lista_nome_jogadores.append(nome_jogador)
  cerebros = 0
  tiros = 0
  # Armazenar informações  do índice, nome, quantidade de cérebros e tiros do jogador
  jogador = [i, nome_jogador, cerebros, tiros]
  lista_jogadores.append(jogador)
print('BEM-VINDOS, JOGADORES: ', lista_nome_jogadores)
print('-'*85)
'''
# Wellington: para fins de teste, já deixei pré-definida uma quantidade de jogadores (3, no caso)
n_jogadores = 3
lista_jogadores = [[0, 'Jogador A', 0, 0],
                   [1, 'Jogador B', 0, 0],
                   [2, 'Jogador C', 0, 0]]
lista_nome_jogadores = ['Jogador A', 'Jogador B', 'Jogador C']

# Wellington: aquele while do seu arquivo original (253 a 376) estava grande demais.
# Dessa maneira, fica difícil de testarmos e ver como está funcionando.
# Assim, vou usar funções para modularizar aquele while grande. Estas funções estão abaixo.
# Para fazer isso, comecei do seu loop mais interno (linhas 274-376) e criei novas funções.
# Note principalmente o aspecto modular do que fiz.

def continuar_jogando():
  # Wellington: para fins de teste, coloquei o "continuar_jogando" igual a 'S' sempre
  #continuar_jogando = str(input('Deseja continuar jogando? [S - SIM | N - NÃO] ')).upper()
  continuar_jogando = 'S'
  sleep(1)

  # Wellington: comentei isto somente para testar todas as jogadas.
  # Também troquei o pass/break por um return mais simples
  '''
  if continuar_jogando != 'S':
    return False
  '''
  return True

# Wellington: note que enviamos as 3 variáveis de bloqueio de dados e o copo
# e como retorno temos as jogadas e o copo
def sortear_dados(primeiro_dado, segundo_dado, terceiro_dado,
                  bloquear_dado1, bloquear_dado2, bloquear_dado3, copo):
  print('='*85)
  print('É hora de jogar os dados!!\n')
  #input('Pressione ENTER para jogar! ')
  # Wellington: comentei a linha acima para que pudesse testar o código mais rápido
  print('='*85)

  print('Dados sorteados: ')
  if bloquear_dado1:
    primeiro_dado, copo = pegar_dados_copo(copo)
    mostrar_cor_dados(primeiro_dado)
  
  if bloquear_dado2:
    segundo_dado, copo = pegar_dados_copo(copo)
    mostrar_cor_dados(segundo_dado)
  
  if bloquear_dado3:
    terceiro_dado, copo = pegar_dados_copo(copo)
    mostrar_cor_dados(terceiro_dado)
  
  print('\nDados restantes no copo: ')
  mostrar_dados_copo(copo)
  print('\n')

  primeira_jogada = " "
  segunda_jogada = " "
  terceira_jogada = " "

  if primeiro_dado != -1:
    primeira_jogada = lancar_dados(primeiro_dado)
  if segundo_dado != -1:
    segunda_jogada = lancar_dados(segundo_dado)
  if terceiro_dado != -1:
    terceira_jogada = lancar_dados(terceiro_dado)

  return primeira_jogada, segunda_jogada, terceira_jogada, \
         primeiro_dado, segundo_dado, terceiro_dado, copo

def atualizar_pontuacoes(primeira_jogada, segunda_jogada, terceira_jogada, vez_do_jogador):
  # Analisar os dados com a face 'P'
  bloquear_dado1 = True
  bloquear_dado2 = True
  bloquear_dado3 = True

  # Verificar score
  cerebros, tiros, passos = consultar_score(primeira_jogada, segunda_jogada, terceira_jogada)
  
  # Verificar se a vítima escapou
  if passos > 0:
    if primeira_jogada == 'P':
      bloquear_dado1 = False
    if segunda_jogada == 'P':
      bloquear_dado2 = False
    if terceira_jogada == 'P':
      bloquear_dado3 = False

  # Pontuação
  lista_jogadores[cod][2] = jogador[2] + cerebros
  lista_jogadores[cod][3] = jogador[3] + tiros

  # Wellington: haviam uns problemas no uso do format aqui. Ajustei.
  print(f'\nJogador: {format(lista_jogadores[cod][1])}')
  print(f'Cérebros: {format(lista_jogadores[cod][2])}')
  print(f'Tiros: {format(lista_jogadores[cod][3])}')

  print(str(lista_jogadores[jogador[0]][3]))
  return bloquear_dado1, bloquear_dado2, bloquear_dado3

def verificar_fim_jogo(copo, vez_do_jogador):
  # Verificar se o jogador morreu
  if lista_jogadores[jogador[0]][3] > 2:
    print('Que pena, você morreu!!\n')
    # Zerar variáveis
    # Wellington: dei uma olhada nas regras do jogo e não me lembro se reseta a pontuação de cérebros mesmo. Acho que não...
    #lista_jogadores[jogador[0]][2] = 0
    lista_jogadores[jogador[0]][3] = 0
    # Resetar o copo
    print('Hora de devolver os dados para o copo!\n')
    sleep(1)
    resetar_copo = []
    copo = armazenar_dados_copo(resetar_copo)
    mostrar_dados_copo(copo)
    vez_do_jogador = False
    return False, copo, vez_do_jogador, True

  # Verificar se o jogador venceu
  if lista_jogadores[jogador[0]][2] > 12:
    print('Parabééééns!!! Você venceu o ZombieDice! \n')
    partida = False
    vez_do_jogador = False
    return False, copo, vez_do_jogador, False

  # Verificar se jogador deseja encerrar sua vez
  if vez_do_jogador:
    #continuar_vez = str(input('Deseja continuar sua vez? [S - SIM | N - NÃO] ')).upper()
    # Wellington: forçando o "continuar_vez" como 'S' para acelerar os testes
    continuar_vez = 'S'
    if continuar_vez == 'S':
      # Wellington: troquei aqui por um return True
      return True, copo, vez_do_jogador, True
    else:
      # Passar para o próximo jogador
      lista_jogadores[jogador[0]][3] = 0
      resetar_copo = []
      copo = armazenar_dados_copo(resetar_copo)
      mostrar_dados_copo(copo)
      vez_do_jogador = False
      # Wellington: troquei aqui por um return False
      return False, copo, vez_do_jogador, True

#-------------------------------------------------------------------------------

# -- INICIALIZAR VARIÁVEIS -- 

# -- Criando o copo e armazenando os 13 dados dentro
copo = []
copo = armazenar_dados_copo(copo)

#-------------------------------------------------------------------------------

# -- JOGABILIDADE --
print('***** Hora de se aventurar no universo zumbi!***** \n')
print('-'*85)

# Iniciar a partida
partida = True

while(partida):
  for jogador in lista_jogadores:
    # Mostrar qual jogador irá iniciar a partida
    #primeiro_jogador = escolher_primeiro_jogador(jogador)
    #print('O jogador {} iniciará a partida!\n' .format(primeiro_jogador))

    # Posição do primeiro jogador
    cod = jogador[0]

    # Mostrar os dados disponíveis no copo
    mostrar_dados_copo(copo)

    # Iniciar a vez do jogador e as variáveis quando algum dado é sorteado
    vez_do_jogador = True
    bloquear_dado1 = True
    bloquear_dado2 = True
    bloquear_dado3 = True

    # Inicializar os dados
    primeiro_dado = -1
    segundo_dado = -1
    terceiro_dado = -1

    while(vez_do_jogador):
      if not continuar_jogando():
        partida = False
        break
      
      primeira_jogada, segunda_jogada, terceira_jogada, \
      primeiro_dado, segundo_dado, terceiro_dado, copo = sortear_dados(
          primeiro_dado, segundo_dado, terceiro_dado,
          bloquear_dado1, bloquear_dado2, bloquear_dado3, copo)
      
      bloquear_dado1, bloquear_dado2, bloquear_dado3 = atualizar_pontuacoes(
          primeira_jogada, segunda_jogada, terceira_jogada, vez_do_jogador)
      
      jogador_deseja_continuar, copo, vez_do_jogador, partida = verificar_fim_jogo(copo, vez_do_jogador)
      display(f'vez_do_jogador: {vez_do_jogador}, partida: {partida}')
      if not jogador_deseja_continuar:
        break

    # Wellington: se terminou a partida, terminou para todos. Saindo desse for
    if not partida:
      break

